{"version":3,"sources":["config/routes.config.js","components/Router/index.less","components/Loading/index.js","components/Router/LoginRoute/index.js","components/Router/PrivateRoute/index.js","components/Router/index.js","serviceWorker.js","reducer/index.js","reducers.js","store.js","index.js"],"names":["module","exports","path","name","component","routes","icon","props","LoginRoute","this","Component","store","rest","render","isAuthenticated","to","pathname","state","from","location","isLoginIng","onLoginSuccess","React","connect","Common","PrivateRoute","getLoadableComponent","componentImportFn","Loadable","loader","loading","Loading","AppRouter","className","style","matchScreen","loopRoutes","matchPath","map","route","key","match","exact","routeConfig","Boolean","window","hostname","initState","appId","modalShow","combineReducers","action","type","data","configureStore","initialState","applyMiddleware","thunkMiddleware","createStore","createStoreWithMiddleware","rootReducer","element","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d24f6140.chunk.js","sourcesContent":["module.exports = [{\n    path: '/',\n    name: 'index',\n    component: ()=>import(/* webpackChunkName: \"home\" */'pages/Home'),\n  }, {\n    path: '/sort',\n    component: ()=>import(/* webpackChunkName: \"sort\" */'pages/Sort'),\n  }, {\n  path: '/',\n  routes: [\n    {\n      path: 'welcome',\n      name: 'welcome',\n      icon: 'smile',\n      component: ()=>import(/* webpackChunkName: \"Welcome\" */'pages/Welcome'),\n    }\n  ]}\n]\n","module.exports = __webpack_public_path__ + \"static/media/index.738360e2.less\";","import React from 'react';\n\nexport default function (props) {\n  return (\n    <div>loading</div>\n  );\n}","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Redirect, Route } from \"react-router-dom\";\n\nclass LoginRoute extends React.Component {\n  render() {\n    let { component: Component, store, ...rest } = this.props\n\n    return (\n      <Route\n        {...rest}\n        render={props => (\n          store.isAuthenticated ? (\n            <Redirect\n              to={{\n                pathname: \"/\",\n                state: { from: props.location },\n              }}\n            />\n          ) : (\n            <Component {...props} isLoginIng={store.isLoginIng} onLoginSuccess={store.onLoginSuccess} />\n          )\n        )}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  store: state.Common\n})\nexport default connect(mapStateToProps)(LoginRoute)\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Redirect, Route } from \"react-router-dom\";\n\nclass PrivateRoute extends React.Component{\n  render(){\n    const { component: Component, store, ...rest } = this.props\n    return (\n      <Route\n        {...rest}\n        render={props => (store.isAuthenticated ? (\n          <Component {...props} />\n        ) : (\n          <Redirect\n            to={{\n              pathname: \"/login\",\n              state: { from: props.location },\n            }}\n          />\n        ))\n        }\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  store: state.Common\n})\n\nexport default connect(mapStateToProps)(PrivateRoute)","import React from 'react';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n} from 'react-router-dom';\nimport Loadable from 'react-loadable';\nimport routeConfig from 'config/routes.config'\nimport Loading from 'components/Loading'\nimport LoginRoute from './LoginRoute'\nimport PrivateRoute from './PrivateRoute'\nimport style from './index.less'\n\n// react-loadable 实现代码分割\nfunction getLoadableComponent(componentImportFn, props) {\n  const Component = Loadable({\n    loader: componentImportFn,\n    loading: Loading,\n  });\n  if (props) {\n    return (\n      <Component {...props} />\n    );\n  }\n  return Component;\n}\n\nfunction loopRoutes(routes, match = {}) {\n  const matchPath = match.path || '';\n  return (\n    // <Switch> 不是分组 <Route> 所必须的，但他通常很有用。 一个 <Switch> 会遍历其所有的子 <Route> 元素，并仅渲染与当前地址匹配的第一个元素。这有助于多个路由的路径匹配相同的路径名\n    // extra:精确匹配\n    <Switch>\n      {\n        routes.map((route) => {\n          const routes = route.routes;\n          if (routes) {\n            return (\n              <Route\n                key={route.path}\n                path={route.path}\n                render={({ match }) => loopRoutes(routes, match)}\n              />\n            );\n          }\n          return (\n            <PrivateRoute\n              exact\n              key={route.path}\n              path={matchPath + route.path}\n              component={getLoadableComponent(route.component)}\n            />\n          );\n        })\n      }\n      <LoginRoute\n        exact\n        path=\"/login\"\n        component={getLoadableComponent(() => import(/* webpackChunkName: \"login\" */'pages/Login'))}\n      />\n      <Route component={getLoadableComponent(() => import(/* webpackChunkName: \"notfound\" */'pages/404'))}/>\n    </Switch>\n  );\n}\n\nconst AppRouter = (props) => (\n  <Router>\n    <div className={style.matchScreen}>\n      {loopRoutes(routeConfig,props)}\n    </div>\n  </Router>\n);\n\nexport default AppRouter","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","const initState = {\n  appId: '',\n  modalShow: false,\n  isAuthenticated:true,\n  isLoginIng:false\n};\n\nexport default function (state = initState, action) {\n  switch (action.type) {\n    case 'SET_APPID':\n      return {\n        ...state,\n        appId: action.data,\n      };\n    case 'SHOW_MODAL':\n      return {\n        ...state,\n        modalShow: true,\n      };\n    default:\n      return state;\n  }\n}\n","import { combineReducers } from 'redux';\n// 通用\nimport Common from 'reducer/index.js';\n\nexport default combineReducers({\n  Common,\n});\n","import { createStore, applyMiddleware } from 'redux';\nimport thunkMiddleware from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst createStoreWithMiddleware = applyMiddleware(\n  thunkMiddleware\n)(createStore);\n\nfunction configureStore(initialState) {\n  return createStoreWithMiddleware(rootReducer, initialState);\n}\n\nexport default configureStore();\n","import React from \"react\";\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport AppRouter from 'components/Router'\nimport * as serviceWorker from './serviceWorker'\nimport store from './store'\n\nconst element = (\n  <Provider store={store}>\n    <AppRouter/>\n  </Provider>\n);\nrender(element, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}